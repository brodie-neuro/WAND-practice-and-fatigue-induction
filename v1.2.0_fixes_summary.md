# WAND v1.2.0 - Bug Fixes, Packaging Corrections, and New Tests

All issues were verified by code inspection and confirmed not covered by existing tests.
All 76 tests pass after these changes (60 original + 3 loop structure + 13 EEG config).

---

## Fix 1: Dual Practice Loop - Infinite Loop Bug (CRITICAL)

**File:** `wand_nback/practice_plateau.py` lines 2444-2468

**Problem:** In the Dual N-back normal-speed practice section, the `passes` counter
increment and the "let's do another block" prompt were **outside** the `while` loop
due to wrong indentation. This meant `passes` was never incremented inside the loop,
so the condition `while passes < 2` was always true, creating an infinite loop. The
only way out was pressing the skip key (5).

The identical Spatial section (lines 2365-2391) had the correct indentation, confirming
this was a copy-paste indentation error.

**Before (broken):**
```python
            # Need two successive normal-speed blocks >= 65 %
            passes = 0
            while passes < 2 and not skip_to_next_stage:
                show_countdown()
                acc, corr, incorr, lapses = run_dual_nback_practice(n=2, num_trials=60)
                elapsed = time.time() - START_TIME
                logging.info(
                    f"Dual-NORMAL Block finished. Accuracy: {acc:.1f}%. Elapsed: {int(elapsed // 60)}m {int(elapsed % 60)}s"
                )
                display_block_results(win, "Dual", acc, corr, incorr, lapses)

                if skip_to_next_stage:
                    break
            # WRONG: these two blocks are OUTSIDE the while loop (same indent as 'while')
            passes = passes + 1 if acc >= 65 else 0
            if passes < 2:
                visual.TextStim(
                    win,
                    text="Let's do another block to make sure the performance is consistent.\n\nPress SPACE to continue.",
                    color="white",
                    height=24,
                    wrapWidth=800,
                ).draw()
                win.flip()
                event.waitKeys(keyList=["space"])
```

**After (fixed):**
```python
            # Need two successive normal-speed blocks >= 65 %
            passes = 0
            while passes < 2 and not skip_to_next_stage:
                show_countdown()
                acc, corr, incorr, lapses = run_dual_nback_practice(n=2, num_trials=60)
                elapsed = time.time() - START_TIME
                logging.info(
                    f"Dual-NORMAL Block finished. Accuracy: {acc:.1f}%. Elapsed: {int(elapsed // 60)}m {int(elapsed % 60)}s"
                )
                display_block_results(win, "Dual", acc, corr, incorr, lapses)

                if skip_to_next_stage:
                    break
                # CORRECT: now INSIDE the while loop (indented under 'while')
                passes = passes + 1 if acc >= 65 else 0
                if passes < 2:
                    visual.TextStim(
                        win,
                        text="Let's do another block to make sure the performance is consistent.\n\nPress SPACE to continue.",
                        color="white",
                        height=24,
                        wrapWidth=800,
                    ).draw()
                    win.flip()
                    event.waitKeys(keyList=["space"])
```

**How to verify:** Compare with the correctly-indented Spatial section at lines 2365-2391
which has the identical structure with `passes` increment inside the loop.

**Test coverage:** No existing tests cover this code path. The quicktest scripts only
run Sequential blocks, not the Dual practice loop.

---

## Fix 2: wand-quicktest Entry Point - Wrong Function Name (CRITICAL)

**File:** `pyproject.toml` line 55

**Problem:** The entry point was defined as `Tests.quicktest_induction:main` but the
file `Tests/quicktest_induction.py` has no `main()` function. The function is called
`run_quicktest()`. Running `wand-quicktest` after pip install would fail with:

```
ImportError: cannot import name 'main' from 'Tests.quicktest_induction'
```

**Before (broken):**
```toml
[project.scripts]
wand-launcher = "wand_nback.launcher:main"
wand-practice = "wand_nback.practice_plateau:main"
wand-induction = "wand_nback.full_induction:main_task_flow"
wand-quicktest = "Tests.quicktest_induction:main"
wand-eeg-test = "wand_nback.eeg_test:main"
```

**After (fixed):**
```toml
[project.scripts]
wand-launcher = "wand_nback.launcher:main"
wand-practice = "wand_nback.practice_plateau:main"
wand-induction = "wand_nback.full_induction:main_task_flow"
wand-quicktest = "Tests.quicktest_induction:run_quicktest"
wand-eeg-test = "wand_nback.eeg_test:main"
```

**How to verify:** Open `Tests/quicktest_induction.py` and search for `def main` — it
does not exist. The actual function is `def run_quicktest(n_back_level=2, num_trials=35,
quicktest=False)` at line 173. All parameters have defaults, so it works as a
no-argument entry point.

---

## Fix 3: Missing Tests/__init__.py (CRITICAL)

**File:** `Tests/__init__.py` (did not exist)

**Problem:** The `Tests` directory had no `__init__.py`, which means Python cannot
import it as a package. The entry point `Tests.quicktest_induction:run_quicktest`
requires `Tests` to be importable. After pip install, `wand-quicktest` would fail with:

```
ModuleNotFoundError: No module named 'Tests'
```

Note: `pyproject.toml` line 59 already lists `Tests` as a package
(`packages = ["wand_nback", "Tests"]`), but without `__init__.py` setuptools cannot
build or install it as a package.

**Fix:** Created an empty `Tests/__init__.py` file (0 bytes).

**How to verify:** Check `Tests/` directory — `__init__.py` must exist. Run
`python -c "import Tests"` from the project root.

---

## Fix 4: MANIFEST.in Referenced Non-Existent Directories

**File:** `MANIFEST.in`

**Problem:** `MANIFEST.in` controls what gets included in source distributions
(`python -m build --sdist`). Three lines pointed to wrong locations:

| Line | Old (broken) | Actual location | Issue |
|------|-------------|-----------------|-------|
| 2 | `recursive-include config *.json` | `wand_nback/config/*.json` | Root `config/` is a duplicate that was just deleted (see Fix 6). The real configs are inside the package. |
| 5 | `recursive-include "Abstract Stimuli" *` | `wand_nback/stimuli/apophysis/` | No directory called "Abstract Stimuli" exists anywhere in the repo. The stimuli PNGs are at `wand_nback/stimuli/apophysis/`. |
| 6 | `recursive-include Logo *` | `wand_nback/logo/` | A root `Logo/` directory does exist with WAND.png, but the package code loads from `wand_nback/logo/WAND.png`. The MANIFEST.in should include the package copy. |

This only affects source distributions (sdist). Wheel builds are unaffected because
`pyproject.toml` `[tool.setuptools.package-data]` correctly specifies the paths.

**Before (broken):**
```
# Include config files
recursive-include config *.json

# Include stimuli and assets
recursive-include "Abstract Stimuli" *
recursive-include Logo *
```

**After (fixed):**
```
# Include config files
recursive-include wand_nback/config *.json

# Include stimuli and assets
recursive-include wand_nback/stimuli *
recursive-include wand_nback/logo *
```

**How to verify:** Run `find . -type d -name "Abstract Stimuli"` — returns nothing.
Run `find . -type d -name config` — shows both `./config` (deleted) and
`./wand_nback/config` (the real one). Check that code loads from `wand_nback/config/`:
- `common.py` line 50: `DEFAULT_CONFIG_DIR = os.path.join(BASE_DIR, "config")` where
  `BASE_DIR` is `wand_nback/`
- `launcher.py` line 54: `CONFIG_DIR = os.path.join(BASE_DIR, "config")` where
  `BASE_DIR` is `wand_nback/`

---

## Fix 5: Version Mismatch Across All Files

**Problem:** All Python files still said `1.1.3` while the intended release is
`1.2.0`. This means `wand_nback.__version__` would return `"1.1.3"` instead of
`"1.2.0"`, and version strings in the GUI launcher and docstrings would be wrong.

**All files updated to 1.2.0:**

| File | What changed | Before | After |
|------|-------------|--------|-------|
| `pyproject.toml` | `version = ` | `"1.1.3"` | `"1.2.0"` |
| `wand_nback/__init__.py` | `__version__ = ` | `"1.1.3"` | `"1.2.0"` |
| `wand_nback/__init__.py` | Docstring `Version:` | `1.1.3` | `1.2.0` |
| `wand_nback/launcher.py` | Docstring `Version:` | `1.1.3` | `1.2.0` |
| `wand_nback/launcher.py` | Splash screen text | `v1.1.3` | `v1.2.0` |
| `wand_nback/launcher.py` | Print statement | `v1.1.3` | `v1.2.0` |
| `wand_nback/block_builder.py` | Docstring `Version:` | `1.1.3` | `1.2.0` |
| `wand_nback/practice_plateau.py` | Docstring `Version:` | `1.1.3` | `1.2.0` |
| `wand_nback/full_induction.py` | Docstring `Version:` | `1.1.3` | `1.2.0` |
| `Tests/quicktest_induction.py` | Docstring `Version:` | `1.1.3` | `1.2.0` |
| `Tests/quicktest_practice.py` | Docstring `Version:` | `1.1.3` | `1.2.0` |
| `.zenodo.json` | `"version":` | `"1.1.3"` | `"1.2.0"` |

**How to verify:** `grep -rn "1.1.3" wand_nback/ Tests/ pyproject.toml .zenodo.json`
should return no matches. Only `Changelog.md` should still reference `1.1.3` (historical).

---

## Fix 6: Deleted Duplicate config/params.json

**File deleted:** `config/params.json` (root level)

**Problem:** Two identical copies of `params.json` existed:
- `config/params.json` (root level - not used by anything)
- `wand_nback/config/params.json` (inside package - used by all code)

The root copy was a leftover. All code loads config via `wand_nback/config/`:
- `common.py` line 50: `DEFAULT_CONFIG_DIR = os.path.join(BASE_DIR, "config")`
  where `BASE_DIR` is `wand_nback/`
- `launcher.py` line 54: `CONFIG_DIR = os.path.join(BASE_DIR, "config")`
  where `BASE_DIR` is `wand_nback/`
- `eeg_test.py` line 55: `os.path.join(base_dir, "config", "params.json")`
  where `base_dir` is `os.path.dirname(os.path.abspath(__file__))` = `wand_nback/`

Having two copies risks someone editing the wrong one.

**Fix:** Deleted `config/params.json`. The package copy at
`wand_nback/config/params.json` remains and is the one used everywhere.

**How to verify:** `ls config/params.json` should fail (file deleted).
`ls wand_nback/config/params.json` should succeed (real config still exists).

---

## Fix 7: Standard Execution Main Loop - Body Outside Loop (CRITICAL)

**File:** `wand_nback/full_induction.py` — `main_task_flow()` function, lines 2395-2545

**Problem:** In `main_task_flow()`, the standard cycle-based execution path (used
when the Block Builder is NOT used) has a `for cycle_num in range(1, max_loops + 1):`
loop. However, the entire loop body — Sequential task, scheduled breaks/measures,
Spatial task, and Dual task — was **outside** the `for` loop due to wrong indentation.
Only the `logging.info("--- STARTING LOOP ITERATION ...")` call was inside the loop.

This meant:
1. The `for` loop just logged "STARTING LOOP ITERATION" for each cycle, doing nothing
2. All task blocks ran only **once** using `cycle_num = max_loops` (the leftover loop variable from Python's scoping)
3. If `max_loops` (e.g. 5) > `spa_blocks` (e.g. 4), the condition `cycle_num <= spa_blocks`
   would be `5 <= 4` = False, so Spatial would **never run**. Same for Dual.

The custom Block Builder execution path (the `if custom_block_order:` branch, lines
2238-2394) was correct — this bug only affected the standard cycle-based `else` branch.

**Before (broken) — full code:**
```python
        else:
            # STANDARD CYCLE-BASED EXECUTION (no Block Builder)
            for cycle_num in range(1, max_loops + 1):
                logging.info(f"--- STARTING LOOP ITERATION {cycle_num} ---")

            # WRONG: everything below is OUTSIDE the for loop (same indent as 'for')
            # 1. SEQUENTIAL N-BACK
            if seq_enabled and cycle_num <= seq_blocks:
                now_str = datetime.now().strftime("%H:%M:%S")
                logging.info(
                    f"[{now_str}] Starting Sequential {n_back_level}-back Task - Block {cycle_num}"
                )
                try:
                    if cycle_num > 1:
                        show_transition_screen(win, "Sequential N-back")

                    is_first = cycle_num == 1

                    seq_res = run_sequential_nback_block(
                        win,
                        n_back_level,
                        num_images,
                        target_percentage=0.5,
                        display_duration=seq_display,
                        isi=seq_isi,
                        num_trials=164,
                        is_first_encounter=is_first,
                        block_number=cycle_num,
                    )

                    save_sequential_results(
                        participant_id, n_back_level, f"Block_{cycle_num}", seq_res
                    )

                    # Store for final summary
                    # Store for final summary    <-- duplicate comment
                    all_sequential_results_list.append((cycle_num, seq_res))
                    elapsed = time.time() - experiment_start_time
                    logging.info(
                        f"Sequential N-back Task - Block {cycle_num} COMPLETED. ..."
                    )

                except Exception as e:
                    logging.error(
                        f"Error in Sequential N-back Task (Block {cycle_num}): {e}"
                    )
                    logging.exception("Exception occurred")

            # 2. SCHEDULED EVENTS
            run_scheduled_events(cycle_num)

            # 3. GROUP (SPATIAL / DUAL)
            if cycle_num % 2 != 0:
                current_order = [task_A_name, task_B_name]
            else:
                current_order = [task_B_name, task_A_name]

            if spa_enabled or dual_enabled:
                logging.info(f"Loop {cycle_num} Group Order: {current_order}")

            for task_type in current_order:
                # --- SPATIAL ---
                if task_type == "SPA":
                    if spa_enabled and cycle_num <= spa_blocks:
                        ...
                        run_adaptive_nback_task(...)
                        spatial_block += 1
                        ...

                # --- DUAL ---
                elif task_type == "DUAL":
                    if dual_enabled and cycle_num <= dual_blocks:
                        ...
                        run_adaptive_nback_task(...)
                        dual_block += 1
                        ...
```

**After (fixed) — full code:**
```python
        else:
            # STANDARD CYCLE-BASED EXECUTION (no Block Builder)
            for cycle_num in range(1, max_loops + 1):
                logging.info(f"--- STARTING LOOP ITERATION {cycle_num} ---")

                # CORRECT: everything below is now INSIDE the for loop (indented under 'for')
                # 1. SEQUENTIAL N-BACK
                if seq_enabled and cycle_num <= seq_blocks:
                    now_str = datetime.now().strftime("%H:%M:%S")
                    logging.info(
                        f"[{now_str}] Starting Sequential {n_back_level}-back Task - Block {cycle_num}"
                    )
                    try:
                        if cycle_num > 1:
                            show_transition_screen(win, "Sequential N-back")

                        is_first = cycle_num == 1

                        seq_res = run_sequential_nback_block(
                            win,
                            n_back_level,
                            num_images,
                            target_percentage=0.5,
                            display_duration=seq_display,
                            isi=seq_isi,
                            num_trials=164,
                            is_first_encounter=is_first,
                            block_number=cycle_num,
                        )

                        save_sequential_results(
                            participant_id, n_back_level, f"Block_{cycle_num}", seq_res
                        )

                        # Store for final summary
                        all_sequential_results_list.append((cycle_num, seq_res))
                        elapsed = time.time() - experiment_start_time
                        logging.info(
                            f"Sequential N-back Task - Block {cycle_num} COMPLETED. ..."
                        )

                    except Exception as e:
                        logging.error(
                            f"Error in Sequential N-back Task (Block {cycle_num}): {e}"
                        )
                        logging.exception("Exception occurred")

                # 2. SCHEDULED EVENTS
                run_scheduled_events(cycle_num)

                # 3. GROUP (SPATIAL / DUAL)
                if cycle_num % 2 != 0:
                    current_order = [task_A_name, task_B_name]
                else:
                    current_order = [task_B_name, task_A_name]

                if spa_enabled or dual_enabled:
                    logging.info(f"Loop {cycle_num} Group Order: {current_order}")

                for task_type in current_order:
                    # --- SPATIAL ---
                    if task_type == "SPA":
                        if spa_enabled and cycle_num <= spa_blocks:
                            ...
                            run_adaptive_nback_task(...)
                            spatial_block += 1
                            ...

                    # --- DUAL ---
                    elif task_type == "DUAL":
                        if dual_enabled and cycle_num <= dual_blocks:
                            ...
                            run_adaptive_nback_task(...)
                            dual_block += 1
                            ...
```

**How to verify:** Open `wand_nback/full_induction.py` and find the `else:` branch
with comment `# STANDARD CYCLE-BASED EXECUTION`. The `for cycle_num` loop should
contain ALL the task code (Sequential, `run_scheduled_events`, Spatial/Dual group)
indented inside it — not just the `logging.info` line.

**Also fixed:** Removed duplicate comment `# Store for final summary` (appeared twice
consecutively).

**Test coverage:** No existing tests cover this code path. Added
`test_induction_main_loop_contains_task_code` (see below).

---

## New Tests: Loop Structure Integrity

**File added:** `Tests/test_loop_structure.py`

Three AST-based tests were added to prevent loop indentation bugs from recurring:

1. **`test_all_passes_loops_have_internal_increment`** - Parses the AST of
   `practice_plateau.py` and verifies that every `while passes < N` loop has a
   `passes = ...` assignment inside its body. If someone accidentally moves the
   increment outside the loop (as happened with the Dual section), this test fails.

2. **`test_spatial_and_dual_loops_are_structurally_identical`** - Verifies that
   all `while passes` loops have consistent structure, catching copy-paste errors
   where one loop diverges from the others.

3. **`test_induction_main_loop_contains_task_code`** - Parses the AST of
   `full_induction.py` and verifies that every `for cycle_num` loop contains
   task execution calls (e.g. `run_scheduled_events`, `run_sequential_nback_block`,
   `run_adaptive_nback_task`) inside its body, not just logging. Also checks that
   the loop body has more than 1 statement.

These tests use Python's `ast` module to inspect the source code structure directly,
so they don't require PsychoPy or any mocking.

---

## New Tests: EEG Trigger Configuration

**File added:** `Tests/test_eeg.py`

13 tests verifying EEG trigger configuration and logic **without requiring any
hardware**. All tests mock the parallel port and serial connections.

### TestEegTestUtility (5 tests) — `wand_nback/eeg_test.py` helper functions:

1. **`test_get_config_path_points_to_package_config`** - Verifies the config path
   resolves to `wand_nback/config/params.json`, not the deleted root copy.

2. **`test_load_config_returns_dict`** - Verifies `load_config()` returns a valid dict.

3. **`test_load_config_has_eeg_section`** - Verifies `params.json` contains the `eeg`
   section with `port_address` and `triggers` keys.

4. **`test_common_port_addresses_are_hex_strings`** - Verifies all 18+ scan addresses
   are valid hex strings (e.g. `"0x378"`, `"0xD010"`).

5. **`test_save_config_writes_json`** - Verifies `save_config()` writes valid JSON to
   disk (uses a temp directory, doesn't modify real config).

### TestSendTriggerLogic (8 tests) — trigger code validation:

6. **`test_trigger_names_resolve_to_codes`** - Verifies every trigger name in
   `params.json` maps to a non-zero integer code.

7. **`test_trigger_codes_are_unique`** - Verifies no two trigger names share the same
   code (duplicates would make EEG data ambiguous).

8. **`test_trigger_codes_are_valid_byte_values`** - Verifies all codes are 0–255
   (required by both parallel port and TriggerBox byte protocol).

9. **`test_expected_trigger_names_exist`** - Verifies key trigger names used by the
   experiment are defined: `experiment_start`, `experiment_end`,
   `sequential_stimulus_onset`, `spatial_stimulus_onset`, `dual_stimulus_onset`,
   `block_start`, `block_end`.

10. **`test_eeg_config_has_required_fields`** - Verifies `enabled`, `port_address`,
    `trigger_duration`, and `triggers` are all present in the config.

11. **`test_trigger_duration_is_reasonable`** - Verifies trigger pulse duration is
    between 1ms and 50ms (too short = missed by amplifier, too long = overlapping).

12. **`test_scan_triggerbox_handles_no_pyserial`** - Verifies `scan_triggerbox()`
    returns `(None, None)` gracefully when `pyserial` is not installed.

13. **`test_try_port_returns_none_on_exception`** - Verifies `try_port()` returns
    `None` when the parallel port hardware raises an exception.

---

## Additional Changes

### `wand-eeg-test` Entry Point

Added `wand-eeg-test = "wand_nback.eeg_test:main"` to `pyproject.toml`
`[project.scripts]` so the EEG trigger test utility is available as a console
command after pip install.

### `.zenodo.json` Description Updated

Replaced the description with a comprehensive summary of WAND's features
(GUI launcher, adaptive N-back tasks, practice calibration, fatigue induction,
SDT metrics, EEG trigger support, pip-installable).

### `Changelog.md` Updated

Added to the existing `[1.2.0]` entry:
- **Fixed** section: `wand-quicktest` entry point, missing `Tests/__init__.py`,
  MANIFEST.in paths, Dual practice loop indentation, Standard execution loop
  indentation, duplicate `config/params.json`
- **Added** section: Loop structure tests (3 AST-based), EEG configuration
  tests (13 mock-based)

---

## Complete List of New Files Created

| File | Purpose |
|------|---------|
| `Tests/__init__.py` | Empty init file so `Tests` is importable as a package |
| `Tests/test_loop_structure.py` | 3 AST-based tests preventing loop indentation regressions |
| `Tests/test_eeg.py` | 13 EEG config/trigger validation tests (no hardware needed) |
| `v1.2.0_fixes_summary.md` | This summary document |

---

## Verification

- All 76 tests pass (60 original + 3 loop structure + 13 EEG, 1 skipped due to PsychoPy init)
- No hardware required — EEG tests validate config, trigger codes, and graceful failure via mocks
- No remaining `1.1.3` references in source files (only in Changelog.md historical entry)
- All version strings are `1.2.0` across every file
- Entry point function `run_quicktest()` has all-default parameters, callable with no args
- Dual loop indentation now matches the working Spatial loop exactly
- Standard execution main loop now contains all task code inside the for loop body
- Block Builder execution path was already correct (unaffected)
- `block_builder.py` and `eeg_test.py` reviewed exhaustively — no issues found
